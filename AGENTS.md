## 方案概述
实施方案
1. 模块架构
nuxt-i18n-code/
├── src/
│   ├── module.ts                 # 模块入口
│   ├── config.ts                 # 类型定义和默认配置
│   ├── runtime/                  # 运行时代码
│   │   ├── plugins/
│   │   │   └── i18n.ts          # i18n 插件
│   │   ├── composables/
│   │   │   └── useI18n.ts       # useI18n composable
│   │   ├── utils/
│   │   │   ├── config.ts        # 运行时配置
│   │   │   ├── state.ts         # 状态管理
│   │   │   └── messages.ts      # 消息处理
│   │   └── middleware/
│   │       └── i18n.global.ts   # 全局中间件(可选)
│   └── templates/
│       └── i18n-config.ts        # 用户配置模板
├── playground/                   # 测试应用
└── package.json
2. 模块核心实现 (module.ts)
// src/module.ts
import { defineNuxtModule, addPlugin, addImports, addTemplate, createResolver } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
export interface ModuleOptions {
  /** 
   * 支持的 locales，类型安全的字符串数组
   * @example ['en', 'zh']
   */
  locales?: string[]
  
  /**
   * 默认 locale
   * @default 'en'
   */
  defaultLocale?: string
  
  /**
   * URL 策略
   * @default 'prefix'
   */
  strategy?: 'prefix' | 'prefix_except_default'
  
  /**
   * 是否检测浏览器语言
   * @default true
   */
  detectBrowserLanguage?: boolean
  
  /**
   * 消息配置函数路径
   * 指向一个 .ts 文件，导出 messages 配置
   */
  messagesPath?: string
}
export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-i18n-code',
    configKey: 'i18nCode',
    compatibility: {
      nuxt: '^3.0.0'
    }
  },
  defaults: {
    locales: ['en', 'zh'],
    defaultLocale: 'en',
    strategy: 'prefix',
    detectBrowserLanguage: true,
    messagesPath: '~/i18n.config.ts'
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    // 1. 验证配置
    validateOptions(options, nuxt)
    // 2. 读取用户的消息配置
    const messagesConfig = await loadMessagesConfig(options.messagesPath, nuxt)
    
    // 3. 生成虚拟配置模块
    addTemplate({
      filename: 'i18n-config.mjs',
      write: true,
      getContents: () => generateConfigModule(options, messagesConfig)
    })
    // 4. 添加 runtime 配置
    nuxt.options.runtimeConfig.i18nCode = {
      locales: options.locales,
      defaultLocale: options.defaultLocale,
      strategy: options.strategy
    }
    // 5. 添加插件
    addPlugin({
      src: resolver.resolve('./runtime/plugins/i18n'),
      mode: 'all'
    })
    // 6. 添加 composables 自动导入
    addImports([
      { name: 'useI18n', from: resolver.resolve('./runtime/composables/useI18n') },
      { name: 'useLocalePath', from: resolver.resolve('./runtime/composables/useI18n') },
      { name: 'useSwitchLocalePath', from: resolver.resolve('./runtime/composables/useI18n') }
    ])
    // 7. 扩展页面路由
    if (options.strategy !== 'no_prefix') {
      nuxt.hook('pages:extend', (pages) => {
        const prefixedPages = []
        
        for (const page of pages) {
          for (const locale of options.locales!) {
            // 默认语言不添加前缀（如果 strategy 是 prefix_except_default）
            if (options.strategy === 'prefix_except_default' && 
                locale === options.defaultLocale) {
              continue
            }
            const newPath = page.path === '/' 
              ? `/${locale}` 
              : `/${locale}${page.path}`
            prefixedPages.push({
              ...page,
              path: newPath,
              name: page.name ? `${locale}___${page.name}` : undefined
            })
          }
        }
        pages.push(...prefixedPages)
      })
    }
    // 8. 添加类型支持
    nuxt.hook('prepare:types', ({ references }) => {
      references.push({
        path: resolver.resolve('./runtime/types.d.ts')
      })
    })
    console.log('✅ nuxt-i18n-code module initialized')
  }
})
// 辅助函数
function validateOptions(options: ModuleOptions, nuxt: Nuxt) {
  if (!options.locales?.length) {
    throw new Error('nuxt-i18n-code: locales must have at least one locale')
  }
  
  if (!options.defaultLocale || !options.locales.includes(options.defaultLocale)) {
    console.warn(`nuxt-i18n-code: defaultLocale "${options.defaultLocale}" not in locales, using "${options.locales[0]}"`)
    options.defaultLocale = options.locales[0]
  }
}
async function loadMessagesConfig(path: string, nuxt: Nuxt) {
  // 这里应该读取用户的 i18n.config.ts 文件
  // 为了简化，这里返回空对象，实际实现需要动态导入
  return {}
}
function generateConfigModule(options: ModuleOptions, messagesConfig: any) {
  return `
// Auto-generated by nuxt-i18n-code module
export const config = ${JSON.stringify({
    locales: options.locales,
    defaultLocale: options.defaultLocale,
    strategy: options.strategy,
    detectBrowserLanguage: options.detectBrowserLanguage
  }, null, 2)}
export const messages = ${JSON.stringify(messagesConfig, null, 2)}
`
}
3. 用户使用示例
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['nuxt-i18n-code'],
  
  i18nCode: {
    locales: ['en', 'zh'],
    defaultLocale: 'en',
    strategy: 'prefix',  // 或 'prefix_except_default'
    messagesPath: './i18n.config.ts'  // 消息配置文件路径
  }
})
// i18n.config.ts - 代码配置方式，不是 JSON!
export default {
  en: {
    hello: 'Hello',
    welcome: 'Welcome, {name}!',
    search: {
      title: 'Search',
      placeholder: 'Enter keywords...'
    }
  },
  zh: {
    hello: '你好',
    welcome: '欢迎, {name}!',
    search: {
      title: '搜索',
      placeholder: '请输入关键词...'
    }
  }
}
<!-- 组件中使用 -->
<script setup lang="ts">
const { t, locale, setLocale } = useI18n()
const localePath = useLocalePath()
const switchLocalePath = useSwitchLocalePath()
// 基础翻译
const greeting = t('hello')
// 参数化翻译
const welcome = t('welcome', { name: 'World' })
// 嵌套翻译
const searchTitle = t('search.title')
// 切换语言
async function switchToChinese() {
  await setLocale('zh')
}
</script>
<template>
  <div>
    <h1>{{ t('hello') }}</h1>
    <NuxtLink :to="localePath('/about')">About</NuxtLink>
    <button @click="switchToChinese">Switch to Chinese</button>
  </div>
</template>
---
总结
模块名称: nuxt-i18n-code
核心理念: 
- ✅ TypeScript 代码配置（非 JSON 文件）
- 类型安全：locales 作为 TypeScript union types
- 零文件 I/O：配置在内存中，无读取文件系统问题
- 轻量级：比 @nuxtjs/i18n 更小更快
适用场景:
- 需要简单 i18n 的小型到中型项目
- 喜欢代码配置而非 JSON 的开发者
- 对包大小敏感的应用
不适用场景:
- 需要复杂功能（复数、数字格式化、SEO hreflang）
- 大型国际化项目需要懒加载
- 需要大量社区插件支持的项目
需要我详细展开某个部分的实现吗？例如：
1. 完整的运行时 composables 实现
2. 类型安全的消息类型生成
3. 浏览器语言检测算法
4. 模块测试策略